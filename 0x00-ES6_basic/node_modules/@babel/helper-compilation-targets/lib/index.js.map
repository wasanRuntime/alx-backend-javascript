{"version":3,"names":["_browserslist","require","_helperValidatorOption","_nativeModules","_lruCache","_utils","_targets","_options","_pretty","_debug","_filterItems","ESM_SUPPORT","browserModulesData","v","OptionValidator","validateTargetNames","targets","validTargets","Object","keys","TargetNames","target","Error","formatMessage","findSuggestion","isBrowsersQueryValid","browsers","Array","isArray","every","b","validateBrowsers","invariant","undefined","String","getLowestVersions","reduce","all","browser","browserName","browserVersion","split","browserNameMap","splitVersion","toLowerCase","isSplitUnreleased","isUnreleasedVersion","semverify","version","isUnreleased","getLowestUnreleased","parsedBrowserVersion","semverMin","e","outputDecimalWarning","decimalTargets","length","console","warn","forEach","value","semverifyTarget","error","nodeTargetParser","parsed","process","versions","node","defaultTargetParser","generateTargets","inputTargets","input","assign","esmodules","resolveTargets","queries","env","resolved","browserslist","mobileToDesktop","targetsCache","LruCache","max","resolveTargetsCached","cacheKey","join","cached","get","set","getTargets","options","_browsers","_browsers2","configPath","shouldParseBrowsers","hasTargets","shouldSearchForConfig","ignoreBrowserslistConfig","loadConfig","config","configFile","path","browserslistEnv","map","queryBrowsers","esmSupportVersion","getHighestUnreleased","result","decimalWarnings","sort","push","parsedTarget","parsedValue"],"sources":["../src/index.ts"],"sourcesContent":["import browserslist from \"browserslist\";\nimport { findSuggestion } from \"@babel/helper-validator-option\";\nimport browserModulesData from \"@babel/compat-data/native-modules\";\nimport LruCache from \"lru-cache\";\n\nimport {\n  semverify,\n  semverMin,\n  isUnreleasedVersion,\n  getLowestUnreleased,\n  getHighestUnreleased,\n} from \"./utils.ts\";\nimport { OptionValidator } from \"@babel/helper-validator-option\";\nimport { browserNameMap } from \"./targets.ts\";\nimport { TargetNames } from \"./options.ts\";\nimport type {\n  Target,\n  Targets,\n  InputTargets,\n  Browsers,\n  BrowserslistBrowserName,\n  TargetsTuple,\n} from \"./types.ts\";\n\nexport type { Target, Targets, InputTargets };\n\nexport { prettifyTargets } from \"./pretty.ts\";\nexport { getInclusionReasons } from \"./debug.ts\";\nexport { default as filterItems, isRequired } from \"./filter-items.ts\";\nexport { unreleasedLabels } from \"./targets.ts\";\nexport { TargetNames };\n\nconst ESM_SUPPORT = browserModulesData[\"es6.module\"];\n\nconst v = new OptionValidator(PACKAGE_JSON.name);\n\nfunction validateTargetNames(targets: Targets): TargetsTuple {\n  const validTargets = Object.keys(TargetNames);\n  for (const target of Object.keys(targets)) {\n    if (!(target in TargetNames)) {\n      throw new Error(\n        v.formatMessage(`'${target}' is not a valid target\n- Did you mean '${findSuggestion(target, validTargets)}'?`),\n      );\n    }\n  }\n\n  return targets;\n}\n\nexport function isBrowsersQueryValid(browsers: unknown): boolean {\n  return (\n    typeof browsers === \"string\" ||\n    (Array.isArray(browsers) && browsers.every(b => typeof b === \"string\"))\n  );\n}\n\nfunction validateBrowsers(browsers: Browsers | undefined) {\n  v.invariant(\n    browsers === undefined || isBrowsersQueryValid(browsers),\n    `'${String(browsers)}' is not a valid browserslist query`,\n  );\n\n  return browsers;\n}\n\nfunction getLowestVersions(browsers: Array<string>): Targets {\n  return browsers.reduce(\n    (all, browser) => {\n      const [browserName, browserVersion] = browser.split(\" \") as [\n        BrowserslistBrowserName,\n        string,\n      ];\n      const target = browserNameMap[browserName];\n\n      if (!target) {\n        return all;\n      }\n\n      try {\n        // Browser version can return as \"10.0-10.2\"\n        const splitVersion = browserVersion.split(\"-\")[0].toLowerCase();\n        const isSplitUnreleased = isUnreleasedVersion(splitVersion, target);\n\n        if (!all[target]) {\n          all[target] = isSplitUnreleased\n            ? splitVersion\n            : semverify(splitVersion);\n          return all;\n        }\n\n        const version = all[target];\n        const isUnreleased = isUnreleasedVersion(version, target);\n\n        if (isUnreleased && isSplitUnreleased) {\n          all[target] = getLowestUnreleased(version, splitVersion, target);\n        } else if (isUnreleased) {\n          all[target] = semverify(splitVersion);\n        } else if (!isUnreleased && !isSplitUnreleased) {\n          const parsedBrowserVersion = semverify(splitVersion);\n\n          all[target] = semverMin(version, parsedBrowserVersion);\n        }\n      } catch (e) {}\n\n      return all;\n    },\n    {} as Record<Target, string>,\n  );\n}\n\nfunction outputDecimalWarning(\n  decimalTargets: Array<{ target: string; value: number }>,\n) {\n  if (!decimalTargets.length) {\n    return;\n  }\n\n  console.warn(\"Warning, the following targets are using a decimal version:\\n\");\n  decimalTargets.forEach(({ target, value }) =>\n    console.warn(`  ${target}: ${value}`),\n  );\n  console.warn(`\nWe recommend using a string for minor/patch versions to avoid numbers like 6.10\ngetting parsed as 6.1, which can lead to unexpected behavior.\n`);\n}\n\nfunction semverifyTarget(target: Target, value: string) {\n  try {\n    return semverify(value);\n  } catch (error) {\n    throw new Error(\n      v.formatMessage(\n        `'${value}' is not a valid value for 'targets.${target}'.`,\n      ),\n    );\n  }\n}\n\n// Parse `node: true` and `node: \"current\"` to version\nfunction nodeTargetParser(value: true | string) {\n  const parsed =\n    value === true || value === \"current\"\n      ? process.versions.node\n      : semverifyTarget(\"node\", value);\n  return [\"node\", parsed] as const;\n}\n\nfunction defaultTargetParser(\n  target: Exclude<Target, \"node\">,\n  value: string,\n): readonly [Exclude<Target, \"node\">, string] {\n  const version = isUnreleasedVersion(value, target)\n    ? value.toLowerCase()\n    : semverifyTarget(target, value);\n  return [target, version] as const;\n}\n\nfunction generateTargets(inputTargets: InputTargets): Targets {\n  const input = { ...inputTargets };\n  delete input.esmodules;\n  delete input.browsers;\n  return input;\n}\n\nfunction resolveTargets(queries: Browsers, env?: string): Targets {\n  const resolved = browserslist(queries, {\n    mobileToDesktop: true,\n    env,\n  });\n  return getLowestVersions(resolved);\n}\n\nconst targetsCache = new LruCache({ max: 64 });\n\nfunction resolveTargetsCached(queries: Browsers, env?: string): Targets {\n  const cacheKey = typeof queries === \"string\" ? queries : queries.join() + env;\n  l